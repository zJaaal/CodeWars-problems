// 4 kyu problem Are you Licensed to write JS?
// https://www.codewars.com/kata/5bb429a97631f02eec00001f
// haven't solved it yet but at least I learned about meta programming, this solution pass all the basic cases

function license(args) {
  this.owner = args[0];
  this.renewed = args[1] || 0;
  this.toString = () =>
    `JSLicense: Licensed to ${this.owner}, renewed ${this.renewed} time(s)`;

  return this;
}

let handler = {
  construct(target, args) {
    if (args.length && args[0].trim().length) {
      return new Proxy(license.bind(null, [args[0]]), handler);
    }
    return new Proxy(
      license.bind(null, [target().owner, target().renewed + 1]),
      handler
    );
  },
  get(target, prop) {
    return target()[prop];
  },
  apply() {
    throw Error("You should create a license using new");
  },
  getPrototypeOf() {
    return Object.getPrototypeOf(new Function());
  },
};

JSLicense = new Proxy(license, handler); // How to even approach this?

License = new JSLicense("Codewars");

anotherLicense = new JSLicense("zJaaal");

newLicense = new new new new new License()()()()();

newAnotherLicense =
  new new new new new new new new anotherLicense()()()()()()()();

console.log("License owner: ");
console.log(newLicense.owner);
console.log("Renewed times: ");
console.log(newLicense.renewed);
console.log("License owner: ");
console.log(newAnotherLicense.owner);
console.log("Renewed times: ");
console.log(newAnotherLicense.renewed);

console.log(Object.getPrototypeOf(License));

// Oh noes! Apparently the JS code camp you're about to apply for is more draconian than ever at their gatekeeping process - they require you to create your own JS license to prove that you're permitted to code in JS.

// You need to complete JSLicense, the master license to generate all further licenses. It should have the following behaviour:

// Any JSLicense cannot be called directly. If this is done, throw an error.
// Constructor accepts one argument owner, which can be of any value. The master JSLicense, when its constructor is called, must be supplied with a owner, otherwise throw an error.
// Any instances of JSLicense should have a property owner that comes from the constructor argument, and renewed which shows how many times the license has been renewed. A new license generated by the master license has renewed set to 0. Moreover, the licenses should have a toString method that should return JSLicense: Licensed to {owner}, renewed {renewed} time(s). Please fill in {owner} and {renewed} by the value of the respective properties. (The toString of the master license is not tested.)
// License is renewed by applying new to an existing license without any arguments. This generates a new object, keeps the owner the same while increasing renewed by 1. However, applying new to an existing license with an argument is equivalent to creating a fresh license from the master JSLicense instead, regardless of whether the new owner is the same as the current owner:
// var license = new JSLicense('Codewars');
// // license.owner should be 'Codewars'
// // license.renewed should be 0
// var renewedLicense = new new new license;
// // renewedLicense.owner should still be 'Codewars'
// // renewedLicense.renewed should become 3
// var reIssuedLicense = new renewedLicense('Gensokyo');
// // reIssuedLicense.owner should become 'Gensokyo'
// // reIssuedLicense.renewed should become 0 as the license has changed hands

// // note that the license is re-issued even if we used new renewedLicense('Codewars') instead, despite that renewedLicense belongs to Codewars.
// Renewing or creating new licenses should not affect the state of the older licenses.
// Equality requirements:

// Every JSLicense should be an instance of all its parents: if lic2 = new lic1 and lic3 = new lic2, lic3 instanceof lic2, lic2 instanceof lic1 and lic3 instanceof lic1 should be true, and false for every other combination. Renewing a license with a name provided as argument is considered as creating a new license from the master license.
// Every JSLicense should be different from each other, so lic1 !== lic2 for every pair of distinct licenses.
// There are also security concerns that you have to deal with:

// owner, renewed and toString cannot be re-assigned. You shouldn't be able to modify an existing license as you please ;-)
// The prototype chain must not be leaked or preserved in any ways, to prevent tracing back to the parent licenses and obtaining their constructor to forge licenses. Specifically, for all licenses, Object.getPrototypeOf(lic) === Object.getPrototypeOf(Function) and Object.getPrototypeOf(lic.prototype) === Object.getPrototypeOf(Function.prototype).
// Some hackers have tried to hack the licenses by using a custom prototype during license creation. All JSLicenses must be immune to prototype hacking: Even if another prototype is used, the new generated license should be identical to one without hacking involved. Not even an error will be thrown: no information will be leaked to these pesky attackers.
// You can guaranteed that JSLicense is called with either 0 or 1 arguments, and the argument owner, if supplied, is always a string.

// Note: Object and Function has been frozen for obvious reasons.
